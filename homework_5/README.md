 # Описание принципа работы написанных bash - скриптов
 
 ## 1. Вывод информации об общем количестве запросов
 
 ```cat ../access.log | wc -l | awk '{print $1}' >> $path```
 
Шаги:

 * ```cat``` - считываем содержимое ```access.log```
 * перенаправляем на вход команде ```wc -l```, которая вернет количество строк
 * перенаправляем результат ```wc -l``` команде ```awk '{print $1}'```, которая оставит только количество строк
 * перенаправляем вывод в файл


## 2. Вывод информации об общем количестве запросов по типу

```cat ../access.log | awk '{gsub(/"/, "", $6); print $6}' | sort | uniq -c | sort -rnk 2 | awk '{printf "%s-%d\n", $2, $1}' >> $path```

Шаги:

 * ```cat``` - считываем содержимое ```access.log```
 * с помощью команды ```awk '{gsub(/"/, "", $6); print $6}'``` задаем вывод только названий типов запросов
 * сортируем с помощью ```sort```, подсчитываем количество вхождений каждого типа с помощью ```uniq -c```
 * сортируем по количеству с помощью ```sort -rnk 2```
 * задаем порядок вывода с помощью ```awk '{printf "%s-%d\n", $2, $1}'```
 * перенаправляем вывод в файл

## 3. Вывод информации о 10-ти самых частых запросах

```cat ../access.log | awk '{print $7}' | sort | uniq -c | sort -rnk 1 | head | awk '{print $2,$1}' >> $path```

Шаги:

  * ```cat``` - считываем содержимое ```access.log```
  * с помощью ```awk '{print $7}'``` оставляем только location
  * ```sort``` - сортируем
  * подсчитываем количество вхождений каждого location с помощью ```uniq -c```
  * сортируем по количеству по убыванию с помощью ```sort -rnk 1```
  * используем ```head``` для вывода первых 10 строк с начала
  * перенаправляем вывод в файл


## 4. Вывод информации о топ 5 самых больших по размеру запросов, которые завершились клиентской (4ХХ) ошибкой

```cat ../access.log | awk '$9 ~ /4[0-9]{2}$/ {print $1,$7,$9,$10}' | sort -rnk 4 | head -n 5 | awk '{print $2,$3,$4,$1}' >> $path```

Шаги:

  * ```cat``` - считываем содержимое ```access.log```
  * с помощью ```awk '$9 ~ /4[0-9]{2}$/ {print $1,$7,$9,$10}'``` оставляем только ip, location, status, size при условии, что status начинается с 4
  * ```sort -rnk 4``` - сортируем по размеру по убыванию
  * ```head -n 5``` - оставляем первые 5 строк
  * перенаправляем вывод в файл


## 5. Вывод информации о топ 5 пользователях по количеству запросов, которые завершились серверной (5ХХ) ошибкой

```cat ../access.log | awk '$9 ~ /5[0-9]{2}$/ {print $1}' | sort -k 1 | uniq -c | sort -rnk 1 | head -n 5 | awk '{print $2,$1}' >> $path```

Шаги:

  * ```cat``` - считываем содержимое ```access.log```
  * с помощью ```awk '$9 ~ /5[0-9]{2}$/ {print $1}'``` оставляем только ip при условии, что статус начинается с 5
  * ```sort -k 1``` - сортируем по ip
  * с помощью ```uniq -c``` считаем кол-во вхождений каждого ip
  * ```sort -rnk 1``` - сортируем по убыванию кол-ва запросов
  * ```head -n 5``` - оставляем только первые 5 строчек
  * перенаправляем вывод в файл




  # Вывод о плюсах и минусах Bash и Python в рамках данной работы
  
  Однозначного победителя не будет, увы и ах. И Bash, и Python хорошо подходят для написания подобного рода/вида небольших скриптов. Bash подкупает своей лаконичностью, но в то же время сею особенность можно засчитать и за минус, ибо повышается порог доступности для понимания с ходу в сравнении с тем же Python-ом, который не так скромен в выражениях, да и думаю для более сложных скриптов Bash не подойдет.

 
 
